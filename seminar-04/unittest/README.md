# Python module unittest

---

В Python встроен модуль **unittest**, который поддерживает автоматизацию тестов, использование общего кода для настройки и завершения тестов, объединение тестов в группы, а также позволяет отделять тесты от фреймворка для вывода информации.

Для автоматизации тестов, unittest поддерживает некоторые важные концепции:

**Испытательный стенд (test fixture)** - выполняется подготовка, необходимая для выполнения тестов и все необходимые действия для очистки после выполнения тестов. Это может включать, например, создание временных баз данных или запуск серверного процесса.

**Тестовый случай (test case)** - минимальный блок тестирования. Он проверяет ответы для разных наборов данных. Модуль unittest предоставляет базовый класс **TestCase**, который можно использовать для создания новых тестовых случаев.

**Набор тестов (test suite)** - несколько тестовых случаев, наборов тестов или и того и другого. Он используется для объединения тестов, которые должны быть выполнены вместе.

**Исполнитель тестов (test runner)** - компонент, который управляет выполнением тестов и предоставляет пользователю результат. Исполнитель может использовать графический или текстовый интерфейс или возвращать специальное значение, которое сообщает о результатах выполнения тестов.

---

### Ещё флаги запуска тестов:

 * `-b (--buffer)` - вывод программы при провале теста будет показан, а не скрыт, как обычно.

 * `-c (--catch)` - `Ctrl+C` во время выполнения теста ожидает завершения текущего теста и затем сообщает результаты на 
 данный момент. Второе нажатие `Ctrl+C` вызывает обычное исключение `KeyboardInterrupt`.

 * `-f (--failfast)` - выход после первого же неудачного теста.

 * `--locals` (начиная с Python 3.5) - показывать локальные переменные для провалившихся тестов.

---

### Обнаружение тестов

`unittest` поддерживает простое обнаружение тестов. Для совместимости с обнаружением тестов, все файлы тестов должны быть модулями или пакетами, импортируемыми из директории верхнего уровня проекта ([см. подробнее о правилах наименования модулей](https://pythonworld.ru/osnovy/rabota-s-modulyami-sozdanie-podklyuchenie-instrukciyami-import-i-from.html#id3 "")).

Обнаружение тестов реализовано в `TestLoader.discover()`, но может быть использовано из командной строки:
```shell
python3 -m  unittest  discover

#-v (--verbose) - подробный вывод.
#-s (--start-directory) directory_name - директория начала обнаружения тестов (текущая по умолчанию).
#-p (--pattern) pattern - шаблон названия файлов с тестами (по умолчанию test*.py).
#-t (--top-level-directory) directory_name - директория верхнего уровня проекта (по умолчанию равна start-directory).
```

---

### Организация тестового кода

Базовые блоки тестирования это тестовые случаи - простые случаи, которые должны быть проверены на корректность.

Тестовый случай создаётся путём наследования от `unittest.TestCase`.

Тестирующий код должен быть самостоятельным, то есть никак не зависеть от других тестов.

Простейший подкласс `TestCase` может просто реализовывать тестовый метод (метод, начинающийся с `test`).

Можно разместить все тесты в том же файле, что и сама программа (таком как `src/widget.py`), но размещение тестов в 
отдельном файле (таком как `test/test_simple.py`/`test/test_default.py`) имеет много преимуществ:

- Модуль с тестом может быть запущен автономно из командной строки.
- Тестовый код может быть легко отделён от программы.
- Меньше искушения изменить тесты для соответствия коду программы без видимой причины.
- Тестовый код должен изменяться гораздо реже, чем программа.
- Протестированный код может быть легче переработан.
- Тесты для модулей на C должны быть в отдельных модулях, так почему же не быть последовательным?
- Если стратегия тестирования изменяется, нет необходимости изменения кода программы.
 
Тестов может быть много, и часть кода настройки может повторяться. К счастью, мы можем определить код настройки 
путём реализации метода `setUp()`, который будет запускаться _перед_ каждым тестом.

Мы также можем определить метод `tearDown()`, который будет запускаться _после_ каждого теста.

---

### Пропуск тестов и ожидаемые ошибки

`unittest` поддерживает пропуск отдельных тестов, а также классов тестов. Вдобавок, поддерживается пометка теста как "не работает, но так и надо".

Пропуск теста осуществляется использованием декоратора `skip()` или одного из его условных вариантов.

Ожидаемые ошибки используют декоратор `expectedFailure()`.

---

### Стресс-тесты

Когда некоторые тесты имеют лишь незначительные отличия, например некоторые параметры, `unittest` позволяет различать 
их внутри одного тестового метода, используя менеджер контекста `subTest()`.

---

### Проверки на успешность

Модуль unittest предоставляет множество функций для самых различных проверок:

```python
assertEqual(a, b) — a == b

assertNotEqual(a, b) — a != b

assertTrue(x) — bool(x) is True

assertFalse(x) — bool(x) is False

assertIs(a, b) — a is b

assertIsNot(a, b) — a is not b

assertIsNone(x) — x is None

assertIsNotNone(x) — x is not None

assertIn(a, b) — a in b

assertNotIn(a, b) — a not in b

assertIsInstance(a, b) — isinstance(a, b)

assertNotIsInstance(a, b) — not isinstance(a, b)

assertRaises(exc, fun, *args, **kwds) — fun(*args, **kwds) порождает исключение exc

assertRaisesRegex(exc, r, fun, *args, **kwds) — fun(*args, **kwds) порождает исключение exc и сообщение соответствует регулярному выражению r

assertWarns(warn, fun, *args, **kwds) — fun(*args, **kwds) порождает предупреждение

assertWarnsRegex(warn, r, fun, *args, **kwds) — fun(*args, **kwds) порождает предупреждение и сообщение соответствует регулярному выражению r

assertAlmostEqual(a, b) — round(a-b, 7) == 0

assertNotAlmostEqual(a, b) — round(a-b, 7) != 0

assertGreater(a, b) — a > b

assertGreaterEqual(a, b) — a >= b

assertLess(a, b) — a < b

assertLessEqual(a, b) — a <= b

assertRegex(s, r) — r.search(s)

assertNotRegex(s, r) — not r.search(s)

assertCountEqual(a, b) — a и b содержат те же элементы в одинаковых количествах, но порядок не важен
```